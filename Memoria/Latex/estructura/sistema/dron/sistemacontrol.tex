\newdefinition{i2c}{Comunicación I2C}{I2C, es un protocolo de comunicación que cuenta con 2 cables: uno de ellos (SCL) indica los pulsos de reloj y el otro (SDA) se encarga de transportar los datos. Al contar con un único cable de datos y ser capaz de comunicar dos o más dispositivo es necesario un maestro que se encargue de mediar la comunicación.}{I2C, es un protocolo de comunicación que cuenta con 2 cables: uno de ellos (SCL) indica los pulsos de reloj y el otro (SDA) se encarga de transportar los datos. Al contar con un único cable de datos y ser capaz de comunicar dos o más dispositivo es necesario un maestro que se encargue de mediar la comunicación\cite{Leens2009}}
\newdefinition{spi}{Comunicación SPI}{SPI, es un protocolo de comunicación usado habitualmente para la transferencia de datos entre equipos electrónicos. Formado por un total de 4 conexiones: CLK o reloj de sincronizaciñon, envío de datos, recepción de datos y un Enable que permite recibir datos en caso de estar activo o negarlos en caso de estar inactivo, de esta forma se puede utilizar el SPI para comunicarse con varios sensores utilizando multiplexación mediante el pin de enable\cite{Leens2009}.}{SPI, es un protocolo de comunicación usado habitualmente para la transferencia de datos entre equipos electrónicos. Formado por un total de 4 conexiones: CLK o reloj de sincronizaciñon, envío de datos, recepción de datos y un Enable que permite recibir datos en caso de estar activo o negarlos en caso de estar inactivo, de esta forma se puede utilizar el SPI para comunicarse con varios sensores utilizando multiplexación mediante el pin de enable\cite{Leens2009}}
\newdefinition{pSerie}{Comunicación Puerto Serie}{Puerto serie, es un protocolo de comunicación digital que aplica la serialización, conversión de los datos a nivel de byte a una serie de pulsos para que puedan ser enviados y recibidos, existen diferentes tipos: UART usado por la Raspberry, USART, EUART.}{Puerto serie, es un protocolo de comunicación digital que aplica la serialización, conversión de los datos a nivel de byte a una serie de pulsos para que puedan ser enviados y recibidos, existen diferentes tipos: UART usado por la Raspberry, USART, EUART}

\paragraph{Placa distribuidora de potencia}\label{SSS:PlacaDistribuidora}

\newacronym{pdb}{PDB}{Pluggable Database}
Un punto crucial de los componentes electrónicos es su alimentación, para favorecer la durabilidad y estabilidad del circuito o circuitos electrónicos se debe aislar el circuito de potencia del circuito lógico mediante elementos como los que contiene la \ac{pdb}: diodos, resistencias y transistores los cuales evitan picos de tensión.

%\begin{figure}[Placa distribuidora de potencia]{FIG:PDBDRON}{Placa distribuidora de potencia con conector XT60.}
%	\image{4cm}{}{pdbDron}
%\end{figure}

Esta placa, ilustrada en la figura 3.1 (6), está conectada a la batería mediante un conector, en este caso se cuenta con un conector XT60, el cual impide conectar cada polo con su opuesto debido a su forma, evitando así cortocircuitos y daños al sistema.
Por otro lado, la PDB distribuye la tensión necesaria al resto de los componentes, entre los que se destacan:


\begin{description}
        \item[ESC:] Hasta un total de 6 controladores de velocidad, en este caso son 4 ESC que funcionan con baterías de 2 a 4 celdas y por tanto de 6 a 16 voltios.
        \item [Circuito 5V:] Circuito de 5 voltios de tensión con un sistema de BEC para evitar picos y conseguir un circuito con alimentación continua y estable, con una corriente continua de 2 amperios y una corriente máxima de 2'5 amperios.
        \item [Circuito 12V:] Circuito de 12 voltios de tensión, con el mismo funcionamiento que el circuito a 5 voltios, con una corriente continua de 500 mA y máxima de 0'8 amperios.
\end{description}


\paragraph{Controlador de vuelo}
\label{SSS:Controlador de vuelo}
%\subsubsection*{Controlador de vuelo\label{SS:CONTROLADORVUELO}}{estructura/sistema/dron/controladorvuelo}

	La placa controladora de vuelo es la unidad de procesamiento del dron encargada de gestionar la señales provenientes del receptor, leer los parámetros de los diferentes sistemas de estabilización y su posterior modificación para proporcionar la potencia adecuada a cada motor.
\paragraph{Placa comercial}
\label{SSSS:Placa comercial}
	La elección de la controladora de vuelo viene determinada sólamente por el protocolo de comunicación que utilice, aunque a día de hoy la mayoría de controladoras cuentan con software reprogramable que se ajusta a los diferentes sistemas de comunicación, como los más conocidos iBUS o sBUS.
	
%	\begin{figure}[Controladora de dron]{FIG:CONTROLADORADRON}{Placa controladora mateksys.}
%	\image{4cm}{}{controladoraDron}
%\end{figure}

	En la controladora de vuelo, ilustrada en la figura 3.1 (7), se pueden conectar el sistema de comunicación, sistema de vídeo, controladores de velocidad de los motores, bocina de emergencia y la antena de comunicación de largo alcance.

%https://www.banggood.com/Matek-F405-OSD-BetaFlight-STM32F405-Flight-Controller-Built-in-OSD-Inverter-for-RC-Multirotor-FPV-Racing-Drone-p-1141282.html?rmmds=search&cur_warehouse=CN

\paragraph{Placa desarrollada}
\label{SSSS:Placa desarrollada}
	\newacronym{tfg}{TFG}{Trabajo final de grado}
En este \ac{tfg} se ha reproducido el sistema de control del dron en una Raspberry Pi 3 B+\cite{raspberryPi}, con el fin de unificar todos los controles en un sólo punto y poder utilizar todas las señales entrantes y salientes para mediciones posteriores.

Para representar el sistema de la controladora de vuelo se ha partido del sistema de descifrado del protocolo de comunicación elegido, iBUS, este protocolo manda paquetes de información a través del puerto serie. La raspberry cuenta con dos pines de comunicación por puerto serie: Rx para recibir la información y Tx para transmitirla.
	
El paquete recibido tiene un tamaño total de 31 bytes, con un byte inicial estándar con contenido igual a 0x55, a continuación encontramos un total de 14 canales con 2 bytes por canal y un checksum al final con un tamaño de 1 byte. El paquete se transmite cada 7 ms con una tasa de baudios de 115200, es decir, un total de 115200 bits por segundo.
Para desglosar el paquete recibido, enviado por el mando, se ha tenido que codificar un algoritmo en python donde se diferencia y se convierte cada uno de los bytes a decimal, obteniendo de esta forma un valor de cada canal entre 1000 y 2000, siendo 1000 el valor mínimo y 2000 el máximo valor posible.

Para poder producir el PWM correcto y enviárselo a los controladores de velocidad, se ha escogido el chip PCA9685 que convierte de digital a PWM y tiene hasta un máximo de 8 canales. Ha sido necesario dicho chip ya que la raspberry no cuenta con el número suficiente de canales para controlar los 4 motores.
La Raspberry cuenta con 3 sistemas de comunicación: I2C\footnote{\dfnpl{i2c}}, SPI\footnote{\dfnpl{spi}} y puerto \footnote{\dfnpl{pSerie}}, para La configuración del chip PCA9685 se ha realizado mediante comunicación por I2C y su respectiva librería de adafruit obtenida por github\cite{Industries}. 

Se ha tenido que indicar desde la raspberry la frecuencia de salida de los PWM, 2000 Hz , y el ciclo de trabajo previamente obtenido por nuestro rango de entrada entre 1000 y 2000.
\paragraph{Funcionamiento de algoritmo codificado}
La Raspberry recibe el paquete de bytes y lo transforma mediante el algoritmo diseñado y codificado en valores entre 1000 y 2000 por cada canal. Por otro lado se usa la librería de Adafruit para el chip PCA9685, pasándole el rango calculado y configurando el PWM a generar a 2KHz de frecuencia.

%\begin{subequations}
%    \begin{equation}[EQ:PQTEntrante]{Paquete 31 bytes entrante}
%		\boxed{55,DD05,DC05,EB03,DC05,E803,D007,D205,D905,E803...}
%		%55 DD05 DC05 EB03 DC05 E803 D007 D205 D905 E803 E803 DC05 DC05 DC05 DC05 234C
%	\end{equation}
%	\begin{equation}[EQ:PQTDescifrado]{Señal descifrada}
%		\boxed{input=[1501,  1500,  1003,  1500,  1000,  2000,  1490,  1497,  1000,  1000,  1500,  1500,  1500,  1500]}
%	\end{equation}
%	\begin{equation}[EQ:EQRango]{Ecuación de obtención de rango}
%			\boxed{rango = 3296 - (input - 1000) * \frac{(3296-2498)}{1000}}
%	\end{equation}
%	\begin{equation}[EQ:EQFuncion]{Función de adafruit, generación de pwm en PCA9685}
%			\boxed{pwm.set_pwm(canal, rangoMinimo, 4095)}
%	\end{equation}
%\end{subequations}

\begin{figure}[Diagrama placa controladora desarrollada]{FIG:DIAGRAMAPLACACONTROLADOR}{Diagrama de placa controladora a alto y bajo nivel. El receptor recibe la señal del mando, que se transmite a la raspberry y que realiza la conversión necesaria para general el PWM correcto utilizando el chip PCA9685 a los 4 canales necesarios, uno para cada esc-motor.}
	\image{1\textwidth}{}{diagramaPlacaControladora2}
\end{figure}

En la figura \ref{FIG:DIAGRAMAPLACACONTROLADOR} se pueden observar dos imágenes, a y b, en la imágen b se muestra a alto nivel como funciona el sistema de gestión de la placa controladora diseñada, mientras que en la imágen a se muestra a bajo nivel el proceso y conversión de los datos desde el receptor hasta los PWM mandados a los motores.

Una vez conseguida la señal de salida PWM en función de la entrada del mando, se modifica la señal a partir de los datos obtenidos por el sensor MPU9250, el cual nos indica la inclinación y fuerzas que se ejercen sobre el dron; de esta forma se mandama la potencia adecuada a cada motor para conseguir un vuelo estable y horizontal. Posteriormente se realizó la estrucuta del programa para la obtención de la potencia de los motores para poder medir el viento a partir de ellos, convirtiendo de esta forma el dron en un propio sensor de viento, no obstante, debido a las dificultades de probar el sistema de estabilización y su ajuste, se decidió trabajar con la placa comercial.

\paragraph{Sistema de comunicación}

	El sistema de comunicación está compuesto por dos componentes, receptor y transmisor, 3.1 (1) y 3.1 (3), y se pueden elegir diferentes tipos teniendo en cuenta su protocolo de comunicación. 
	
	El sistema de comunicación tiene diferentes protocolos para transmitir la información, utiliza un protocolo entre emisor y receptor y otro distinto entre receptor y unidad de procesamiento o controladora de vuelo\cite{Eric2017}.
	
%	\begin{figure}[Mando FlySky dron]{FIG:MANDODRON}{Mando FlySky para dron.}
%	\image{4cm}{}{mandoDron}
%\end{figure}	
	
	El protocolo de comunicación entre emisor y receptor tiene que ser siempre igual, es por eso que la mayoría de mandos, emisores, incluyen un receptor estándar. En este caso se ha utilizado un pack FlySky emisor-receptor.
	
	\newacronym{ppm}{PPM}{Parts per million}
	En el caso del protocolo entre el receptor y la unidad de procesamiento podemos encontrar señales PWM, PPM, SBUS, iBus entre otras. La diferencia entre estos protocolos es la forma de estructurar el paquete de datos o la conexión que hay que realizar a nivel de hardware. Por su simplicidad y comodidad se ha utilizado el protocolo iBus que cuenta con un paquete de transmisión de 31 bytes.
	