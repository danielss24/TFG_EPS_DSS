%%En \LaTeXe se denomina entorno flotante a aquel en el que es el compilador el que decide el lugar más conveniente para situarlos. Por eso es importante que todos estos elementos tengan una etiqueta (\textsl{label}) y que en el texto sean referenciados. Nunca hay que utilizar las expresiones `La siguiente figura ...' o `La siguiente tabla ...' sino que hay que utilizar expresiones como `En la figura 1.3' o `En la tabla 2.7'. Para ello es necesario utilizar el comando \textbf{\textbackslash ref} como se indica en la sección \ref{SEC:HIPERENLACES}. Muchos de los elementos vistos en este capítulo son entornos flotantes y es necesario tenerlo en cuenta a la hora de diseñar. Cuando corresponda se indicará si el elemento es flotante o no lo es.
Este capítulo consta de cuatro secciones, cada una de ellas correspondiente a un conjunto de datos sobre el que se han aplicado los algoritmos expuestos en el capítulo \ref{CAP:ALGORITMOS}. 

Partiendo de una división inicial de los datos en un conjunto de train y test (los criterios para dicha división se detallarán por separado en cada sección), para cada usuario en el conjunto de datos, se selecciona un item conforme dicte el algoritmo. A continuación se comprueba en el conjunto de test si el usuario ha evaluado el item, en caso de no disponer de dicha evaluación, la selección no se tiene en cuenta, en caso contrario, se evalúa el $recall$ en tiempo $t$ atendiendo a la fómula \ref{EQ:RECALL}.
\begin{equation} [EQ:RECALL]{Recall}
    recall(t) = \dfrac{\sum_{n=1}^{t} r(u_{t}, i_{t})}{tama\tilde{n}o \ inicial \ test}
\end{equation}


Donde $u_{t}, \ i_{t}$ denota la pareja usuario-item seleccionada en tiempo $t$, y $r(u, t)$ denota el valor dado por el usuario al item: 1 si lo valoró positivamente y 0 si no.

Para todos los algoritmos se ha realizado una búsqueda en rejilla de sus parámetros. Los resultados se muestran con dos gráficas para cada experimento. La primera de ellas corresponde a una evolución temporal del $recall$ en función del número de épocas (se considera como una época, una iteración completa en el conjunto de usuarios). En este tipo de gráfica, cada combinación de los parámetros del algoritmo se representa con un color diferente.  El segundo tipo de gráfica es un corte a la mitad de iteraciones de la gráfica anterior, que permite comprender cómo afectan los parámetros escogidos a la evolución en el $recall$.
