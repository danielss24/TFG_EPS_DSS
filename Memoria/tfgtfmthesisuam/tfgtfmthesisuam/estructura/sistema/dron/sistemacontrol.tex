\paragraph{Placa distribuidora de potencia}\label{SSS:PlacaDistribuidora}
%\subsubsection*{Placa distribuidora de potencia\label{SS:PDB}}{estructura/sistema/dron/pdb}
\newacronym{pdb}{PDB}{Pluggable Database}
Un punto crucial de los componentes electrónicos es su alimentación, para favorecer la durabilidad y estabilidad del circuito o circuitos electrónicos debemos aislar el circuito de potencia del circuito lógico mediante elementos como los que contiene la \ac{pdb}: diodos, resistencias y transistores los cuales evitan picos de tensión.

%\begin{figure}[Placa distribuidora de potencia]{FIG:PDBDRON}{Placa distribuidora de potencia con conector XT60.}
%	\image{4cm}{}{pdbDron}
%\end{figure}

Esta placa, 3.1 (6), está conectada a la batería mediante un conector, en este caso contamos con un conector XT60, el cual impide conectar cada polo con su opuesto debido a su forma, evitando así cortocircuitos y daños al sistema.
Por otro lado, la PDB distribuye la tensión necesaria al resto de los componentes, entre los que destacamos:



\begin{description}
        \item[ESC:] Hasta un total de 6 controladores de velocidad, en este caso son 4 ESC que funcionan con baterías de 2 a 4 celdas y por tanto desde 6 a 16 voltios.
        \item [Circuito 5V:] Circuito de 5 voltios de tensión con un sistema de BEC para evitar picos y conseguir un circuito con alimentación continua y estable, con una corriente continua de 2 amperios y una corriente máxima de 2'5 amperios.
        \item [Circuito 12V:] Circuito de 12 voltios de tensión, con el mismo funcionamiento que el circuito a 5 voltios, con una corriente continua de 500 mA y máxima de 0'8 amperios.
\end{description}


\paragraph{Controlador de vuelo}
\label{SSS:Controlador de vuelo}
%\subsubsection*{Controlador de vuelo\label{SS:CONTROLADORVUELO}}{estructura/sistema/dron/controladorvuelo}

	La placa controladora de vuelo es la unidad de procesamiento del dron encargada de gestionar la señales provenientes del receptor, leer los parámetros de los diferentes sistemas de estabilización y su posterior modificación para proporcionar la potencia adecuada a cada motor.
\paragraph{Placa comercial}
\label{SSSS:Placa comercial}
	La elección de la controladora de vuelo viene determinada sólamente por el protocolo de comunicación que utilice, aunque a día de hoy la mayoría de controladoras cuentan con software reprogramable que se ajusta a los diferentes sistemas de comunicación, como los mas conocidos iBUS o sBUS.
	
%	\begin{figure}[Controladora de dron]{FIG:CONTROLADORADRON}{Placa controladora mateksys.}
%	\image{4cm}{}{controladoraDron}
%\end{figure}

	En la controladora de vuelo, 3.1 (7), pueden conectarse el sistema de comunicación, sistema de vídeo, controladores de velocidad de los motores, bocina de emergencia y la antena de comunicación de largo alcance.

%https://www.banggood.com/Matek-F405-OSD-BetaFlight-STM32F405-Flight-Controller-Built-in-OSD-Inverter-for-RC-Multirotor-FPV-Racing-Drone-p-1141282.html?rmmds=search&cur_warehouse=CN

\paragraph{Placa desarrollada}
\label{SSSS:Placa desarrollada}
	\newacronym{tfg}{TFG}{Trabajo final de grado}
	En este \ac{tfg} he reproducido el sistema de control del dron en una Raspberry Pi 3 B+, con el fin de unificar todos los controles en un solo punto y poder utilizar todas señales entrantes y salientes para mediciones posteriores.
	
	Para representar el sistema de la controladora de vuelo he partido del sistema de descifrado del protocolo de comunicación elegido, iBUS, este protocolo manda paquetes de información a través del puerto serie. La raspberry cuenta con dos pines de comunicación por puerto serie: Rx para recibir la información y Tx para transmitirla.
El paquete recibido tiene un tamaño total de 31 bytes, con un byte inicial estándar con contenido igual a 0x55, a continuación encontramos un total de 14 canales con 2 bytes por canal y un checksum al final con un tamaño de 1 byte. El paquete se transmite cada 7 ms con una tasa de baudios de 115200, es decir, un total de 115200 bits por segundo.
Para desglosar el paquete recibido, enviado por el mando, he codificado un algoritmo en python donde diferencio y convierto cada uno de los bytes a decimal, obteniendo de esta forma un valor de cada canal entre 1000 y 2000, siendo 1000 el valor mínimo y 2000 el máximo valor posible.

Para poder producir el PWM correcto y enviárselo a los controladores de velocidad, he escogido el chip PCA9685 que convierte de digital a PWM y tiene hasta un máximo de 8 canales. Ha sido necesario dicho chip ya que la raspberry no cuenta con el número suficiente de canales para controlar los 4 motores.
La configuración del chip PCA9685 se ha realizado mediante comunicación por I2C\footnote{I2C, es un protocolo de comunicación que cuenta con 2 cables: uno de ellos (SCL) indica los pulsos de reloj y el otro (SDA) se encarga de transportar los datos. Al contar con un único cable de datos y ser capaz de comunicar dos o más dispositivo es necesario de un maestro que se encargue de mediar la comunicación.} y su respectiva librería de adafruit obtenida por github. 

He tenido que indicar desde la raspberry la frecuencia de salida de los PWM, 2000 Hz , y el ciclo de trabajo previamente obtenido por nuestro rango de entrada entre 1000 y 2000.\cite{Industries}
\paragraph{Funcionamiento de algoritmo codificado}
La Raspberry recibe el paquete de bytes\ref{EQ:PQTEntrante} y lo transforma mediante el algoritmo diseñado y codificado en valores entre 1000 y 2000 por cada canal\ref{EQ:PQTDescifrado}. Por otro lado se usa la librería de Adafruit para el chip PCA9685, pasándole el rango obtenido mediante la fórmula\ref{EQ:Rango} y configurando el PWM a generar a 2KHz de frecuencia, quedando la función en python de la forma mostrada en la ecuación \ref{EQ:Funcion}.
%\begin{description}
%\item[Input:] mínimo de 1000 y máximo de 2000
%\item[Output:] señal PWM a 2Khz de frecuencia y un ciclo de trabajo de 125us hasta un máximo de 250us
%\end{description}
%\paragraph{PCA9685}
%\begin{description}
%\item[Input:] canal de 1 a 8, mínimo rango entre 3296 y 2498, máximo rango fijo 4095
%\item[Output sistema:] señal PWM a 2Khz de frecuencia y un ciclo de trabajo de 125us hasta un máximo de 250us
%\end{description}
\begin{subequations}
    \begin{equation}[EQ:PQTEntrante]{Paquete 31 bytes entrante}
		\boxed{55,DD05,DC05,EB03,DC05,E803,D007,D205,D905,E803...}
		%55 DD05 DC05 EB03 DC05 E803 D007 D205 D905 E803 E803 DC05 DC05 DC05 DC05 234C
	\end{equation}
	\begin{equation}[EQ:PQTDescifrado]{Señal descifrada}
		\boxed{input=[1501,  1500,  1003,  1500,  1000,  2000,  1490,  1497,  1000,  1000,  1500,  1500,  1500,  1500]}
	\end{equation}
	\begin{equation}[EQ:EQRango]{Ecuación de obtención de rango}
			\boxed{rango = 3296 - (input - 1000) * \frac{(3296-2498)}{1000}}
	\end{equation}
	\begin{equation}[EQ:EQFuncion]{Función de adafruit, generación de pwm en PCA9685}
			\boxed{pwm.set_pwm(canal, rangoMínimo, 4095)}
	\end{equation}
\end{subequations}

\begin{figure}[Diagrama placa controladora desarrollada]{FIG:DIAGRAMAPLACACONTROLADOR}{Diagrama de placa controladora. El receptor obtiene la señal emitida por el mando y la envía a la raspberry mediante el protocolo iBus. La raspberry descifra el paquete utilizando el algoritmo desarrollado  en python y obteniendo valores entre 1000 y 2000 por cada canal. Posteriormente genera la señal que tiene que enviar al controlador PCA9685 mediante la librería de adafruit. El controlador PCA9685 convierte los datos obtenidos en PWM que manda por 4 canales a los ESC-Motores.}
	\image{1\textwidth}{}{diagramaPlacaControladora2}
\end{figure}

Una vez conseguida la señal de salida PWM en función de la entrada del mando, modifico la señal a partir de los datos obtenidos por el sensor MPU9250, el cual nos indica la inclinación y fuerzas que se ejercen sobre el dron; de esta forma mandamos la potencia adecuada a cada motor para conseguir un vuelo estable y horizontal. Debido a las dificultades de probar el sistema de estabilización y su ajuste, decidí trabajar con la placa comercial.

\paragraph{Sistema de comunicación}

 %https://es.banggood.com/FlySky-FS-i6-2_4G-6CH-AFHDS-RC-Transmitter-With-FS-iA6B-Receiver-p-983537.html?gmcCountry=ES&currency=EUR&createTmp=1&utm_source=googleshopping&utm_medium=cpc_bgcs&utm_content=garman&utm_campaign=pla-esg-rctoys-radio-pc&ad_id=338479731096&gclid=CjwKCAjw2cTmBRAVEiwA8YMgzS7EVYrO8PpApLkYJTjOdKBY6DY7hsZJ_vUVyxS805q55G8okvvf6RoCRSQQAvD_BwE&ID=42481&cur_warehouse=CN
	El sistema de comunicación está compuesto por dos componentes, receptor y transmisor, 3.1 (1) y 3.1 (3), y se pueden elegir diferentes tipos teniendo en cuenta su protocolo de comunicación. 
	
	El sistema de comunicación tiene diferentes protocolos para transmitir la información, utiliza un protocolo entre emisor y receptor y otro distinto entre receptor y unidad de procesamiento o controladora de vuelo.\cite{Eric2017}
	
%	\begin{figure}[Mando FlySky dron]{FIG:MANDODRON}{Mando FlySky para dron.}
%	\image{4cm}{}{mandoDron}
%\end{figure}	
	
	El protocolo de comunicación entre emisor y receptor tiene que ser siempre igual, es por eso que la mayoría de mandos, emisores, incluyen un receptor estándar. En mi caso he utilizado un pack FlySky emisor-receptor.
	
	\newacronym{ppm}{PPM}{Parts per million}
	En el caso del protocolo entre el receptor y la unidad de procesamiento podemos encontrar señales PWM, PPM, SBUS, iBus entre otras. La diferencia entre estos protocolos es la forma de estructurar el paquete de datos o la conexión que hay que realizar a nivel de hardware. Por su simplicidad y comodidad he utilizado el protocolo iBus que cuenta con un paquete de transmisión de 31 bytes.
	